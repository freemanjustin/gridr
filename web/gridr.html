<!DOCTYPE html><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">    <meta name="apple-mobile-web-app-capable" content="yes">    <title>gridr</title>    <link rel="stylesheet" href="../theme/default/style.css" type="text/css">    <link rel="stylesheet" href="style.css" type="text/css">    <script src="../lib/OpenLayers.js" type="text/javascript"></script>    <script type="text/javascript">        var map, control;        var polygonFeature;        function updateXML(){                    // get polygon bounds            var ratio_local = control.ratio;            var scale_local = control.scale;            var center_local = control.center;            var angle = control.rotation;            var polyBounds = polygonFeature.geometry.getVertices();                    var width = distanceBetweenPoints(polyBounds[0], polyBounds[1]);            var height = distanceBetweenPoints(polyBounds[0], polyBounds[3]);                        var input_resolution = document.getElementById('resolution').value;            var input_mindepth = document.getElementById('mindepth').value;                         var xmlString = "&lt;grid&gt;";            xmlString += "<br>&nbsp; &lt;params&gt;"            xmlString += "<br>&nbsp;&nbsp;  &lt;corner_lat&gt;" + polyBounds[0].y + "&lt;/corner_lat&gt;";            xmlString += "<br>&nbsp;&nbsp;  &lt;corner_lon&gt;" + polyBounds[0].x + "&lt;/corner_lon&gt;";            xmlString+= "<br>&nbsp;&nbsp;  &lt;width&gt;" + width + "&lt;/width&gt;";            xmlString+= "<br>&nbsp;&nbsp;  &lt;length&gt;" + height + "&lt;/length&gt;";            xmlString+= "<br>&nbsp;&nbsp;  &lt;angle&gt;" + angle + "&lt;/angle&gt;";            xmlString+= "<br>&nbsp;&nbsp;  &lt;resolution&gt;" + input_resolution + "&lt;/resolution&gt;";            xmlString+= "<br>&nbsp;&nbsp;  &lt;vertical_levels&gt;" + 0 + "&lt;/vertical_levels&gt;";            xmlString += "<br>&nbsp; &lt;/params&gt;"                         xmlString += "<br>&nbsp; &lt;bathymetry&gt;"            xmlString += "<br>&nbsp;&nbsp;  &lt;filename&gt;" + "bathy4.nc" + "&lt;/filename&gt;";            xmlString += "<br>&nbsp;&nbsp;  &lt;lat_coord&gt;" + "lat" + "&lt;/lat_coord&gt;";            xmlString += "<br>&nbsp;&nbsp;  &lt;lon_coord&gt;" + "lon" + "&lt;/lon_coord&gt;";            xmlString += "<br>&nbsp;&nbsp;  &lt;field&gt;" + "bath" + "&lt;/field&gt;";                         xmlString += "<br>&nbsp;&nbsp;  &lt;min_depth&gt;" + input_mindepth + "&lt;/min_depth&gt;";                         xmlString += "<br>&nbsp; &lt;/bathymetry&gt;"            xmlString +=   "<br>&lt;/grid&gt;";            document.getElementById("xmlOutput").innerHTML = xmlString;                         }        function map_bearing(latlng1, latlng2){                        var latitude1 = (latlng1.x);            var longitude1 = (latlng1.y);            var latitude2 = (latlng2.x);            var longitude2 = (latlng2.y);                        var x = (longitude2 - longitude1)*Math.PI/180.0;;            var y = (latitude2 - latitude1)*Math.PI/180.0;;                        var map_brng = Math.atan2(y, x)*180.0/Math.PI;                    return(map_brng);            }        function distanceBetweenPoints(latlng1, latlng2){                        var p1 = new OpenLayers.Geometry.Point(latlng1.x, latlng1.y);            var p2 = new OpenLayers.Geometry.Point(latlng2.x, latlng2.y);            var line = new OpenLayers.Geometry.LineString([p1, p2]);            return(line.getGeodesicLength(new OpenLayers.Projection("EPSG:4326")));        }        function init(){            map = new OpenLayers.Map('map', {allOverlays: true, projection:"EPSG:4326",controls: [                    new OpenLayers.Control.ScaleLine(),                    new OpenLayers.Control.MousePosition(),                    new OpenLayers.Control.Navigation(),new OpenLayers.Control.Zoom()                ]});            var wmsLayer = new OpenLayers.Layer.WMS( "OpenLayers WMS",                    "http://vmap0.tiles.osgeo.org/wms/vmap0?", {layers: 'basic'},{wrapDateLine: true});                                bath_layer = new OpenLayers.Layer.WMS( "Bathymetry",                "http://<<<opendap.URL>>>:8080/thredds/wms/marvl/bathy4.nc",                {layers:'bath',                transparent:true,                format:'image/png',colorscalerange:'-6118,3301',styles:'boxfill/occam'},                {isBaseLayer: false, gutter: 15,wrapDateLine: true, visibility: true, opacity: 0.75, transitionEffect: 'resize',singleTile: true, ratio: 1},                {'buffer':4});                        var renderer = OpenLayers.Util.getParameters(window.location.href).renderer;            renderer = (renderer) ? [renderer] : OpenLayers.Layer.Vector.prototype.renderers;            // the layer that we want to transform features on            var vectorLayer = new OpenLayers.Layer.Vector("Simple Geometry", {                styleMap: new OpenLayers.StyleMap({                    // a nice style for the transformation box                    "transform": new OpenLayers.Style({                        display: "${getDisplay}",                        cursor: "${role}",                        pointRadius: 5,                        fillColor: "white",                        fillOpacity: 1,                        strokeColor: "black"                    }, {                        context: {                            getDisplay: function(feature) {                                // hide the resize handle at the south-east corner                                return feature.attributes.role === "se-resize" ? "none" : "";                            }                        }                    }),                    "rotate": new OpenLayers.Style({                        display: "${getDisplay}",                        pointRadius: 10,                        fillColor: "#ddd",                        fillOpacity: 1,                        strokeColor: "black"                    }, {                        context: {                            getDisplay: function(feature) {                                // only display the rotate handle at the south-east corner                                return feature.attributes.role === "se-rotate" ? "" : "none";                            }                        }                    })                }),                renderers: renderer            });            // create the TransformFeature control, using the renderIntent            // from above            control = new OpenLayers.Control.TransformFeature(vectorLayer, {                renderIntent: "transform",                rotationHandleSymbolizer: "rotate",                rotate: true,                irregular: true            });            map.addControl(control);            // create a polygon feature from a linear ring of points            var point = new OpenLayers.Geometry.Point(145.0, -20.0);            var pointList = [];            // add a box to the map            var newPoint = new OpenLayers.Geometry.Point(point.x, point.y);            pointList.push(newPoint);            var newPoint = new OpenLayers.Geometry.Point(point.x+10.0, point.y);            pointList.push(newPoint);            var newPoint = new OpenLayers.Geometry.Point(point.x+10.0, point.y+5.0);            pointList.push(newPoint);            var newPoint = new OpenLayers.Geometry.Point(point.x, point.y+5.0);            pointList.push(newPoint);            pointList.push(pointList[0]);            var linearRing = new OpenLayers.Geometry.LinearRing(pointList);            polygonFeature = new OpenLayers.Feature.Vector(                new OpenLayers.Geometry.Polygon([linearRing]));            map.addLayers([wmsLayer,bath_layer,vectorLayer]);            map.setCenter(new OpenLayers.LonLat(point.x, point.y), 4);            vectorLayer.addFeatures([polygonFeature]);            // start with the transformation box on polygonFeature            control.setFeature(polygonFeature, {rotation: 0.0, scale: 1.0, ratio: 1.0, irregular: true});            // get polygon bounds after interaction            control.events.register('transformcomplete',control, function() {                updateXML();                }            )        }    </script>  </head>  <body onload="init()">    <h1 id="title">gridr</h1>    <div style="text-align: right">        <div dir="rtl" id="map" class="jmap"></div>    </div>    <form>        grid resolution (m) <input type="number" name="resolution" id="resolution" onkeydown="if (event.keyCode == 13) document.getElementById('update').click()" value="1000.0"><br>        <select>            <option value="bath4.nc">GA Bathymetry</option>        </select><br>        bathymetry minimum depth <input type="number" name="mindepth" id="mindepth" onkeydown="if (event.keyCode == 13) document.getElementById('update').click()" value="1.0"><br>        <input type="button" value="update" id="update" onclick="updateXML()">    </form>    <div id="xmlOutput">    </div>  </body></html>